{"version":3,"file":"index.js","sources":["../src/core/astBuilder.ts","../src/core/tokenizer.ts","../src/core/parser.ts","../src/index.ts"],"sourcesContent":["import type {\r\n  ASTAnyValue,\r\n  ASTArray,\r\n  ASTBoolean,\r\n  ASTChildren,\r\n  ASTNull,\r\n  ASTNumber,\r\n  ASTObject,\r\n  ASTObjectKey,\r\n  ASTResult,\r\n  ASTString,\r\n} from \"../types/ast\";\r\nimport type TokenizerResult from \"../types/tokenizerResult\";\r\n\r\n/**\r\n * Unraw a string to transform for example \\\\n to \\n\r\n * @param rawString\r\n * @returns\r\n */\r\nfunction unrawString(rawString: string) {\r\n  return rawString.replace(/\\\\(.)/g, function (_, char) {\r\n    if (char === \"n\") return \"\\n\";\r\n    if (char === \"r\") return \"\\r\";\r\n    if (char === \"t\") return \"\\t\";\r\n    if (char === \"b\") return \"\\b\";\r\n    if (char === \"f\") return \"\\f\";\r\n    if (char === \"v\") return \"\\v\";\r\n    return char;\r\n  });\r\n}\r\n\r\nclass ASTBuilder {\r\n  /**\r\n   * Return the error message for a given token\r\n   * @param token\r\n   * @returns\r\n   */\r\n  getErrorMessage(token: TokenizerResult) {\r\n    return `\"${token.value}\" is not valid JSON\\nline: ${token.startLine}, column: ${token.startColumn}`;\r\n  }\r\n\r\n  /**\r\n   * Format a string token to remove useless quotes and parse unicode\r\n   * @param str\r\n   * @returns\r\n   */\r\n  private formatStr(str: string) {\r\n    const content = str.substring(1, str.length - 1); //We remove useless quotes\r\n    return unrawString(content); // turn \\\\n into \\n ...\r\n  }\r\n\r\n  private appendBoolean(token: TokenizerResult): ASTBoolean {\r\n    return {\r\n      type: \"BOOLEAN\",\r\n      value: token.type === \"TRUE_BOOLEAN\" ? true : false,\r\n    };\r\n  }\r\n\r\n  private appendNullValue(token: TokenizerResult): ASTNull {\r\n    return {\r\n      type: \"NULL_VALUE\",\r\n      value: null as null,\r\n    };\r\n  }\r\n\r\n  private appendString(token: TokenizerResult): ASTString {\r\n    return {\r\n      type: \"STRING\",\r\n      value: this.formatStr(token.value),\r\n    };\r\n  }\r\n\r\n  private appendArray(token: TokenizerResult): ASTArray {\r\n    return {\r\n      type: \"ARRAY\",\r\n      properties: [],\r\n    };\r\n  }\r\n\r\n  private appendObject(token: TokenizerResult): ASTObject {\r\n    return {\r\n      type: \"OBJECT\",\r\n      properties: [],\r\n    };\r\n  }\r\n\r\n  private appendNumber(token: TokenizerResult): ASTNumber {\r\n    return {\r\n      type: \"NUMBER\",\r\n      value: Number(token.value),\r\n    };\r\n  }\r\n\r\n  private appendKey(token: TokenizerResult): ASTObjectKey {\r\n    return {\r\n      type: \"OBJECT_KEY\",\r\n      name: this.formatStr(token.value),\r\n      value: null,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build the AST for given tokens\r\n   * @param tokens\r\n   * @returns\r\n   */\r\n  buildAST(tokens: TokenizerResult[]) {\r\n    const tree: ASTResult = { type: \"JSON\", value: null };\r\n    const childrens: ASTChildren[] = [tree];\r\n\r\n    let lastScannedToken: TokenizerResult = null;\r\n    for (let i = 0; i < tokens.length; ++i) {\r\n      const actualToken = tokens[i];\r\n      const actualChild = childrens[childrens.length - 1];\r\n\r\n      const addASTBranch = (branch: ASTAnyValue) => {\r\n        if (\r\n          actualChild.type === \"ARRAY\" &&\r\n          lastScannedToken !== null &&\r\n          lastScannedToken.type !== \"START_BRACKET\" &&\r\n          lastScannedToken.type !== \"COMA\"\r\n        ) {\r\n          throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n        }\r\n\r\n        if (actualChild.type === \"OBJECT\" && branch.type !== \"OBJECT_KEY\") {\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n        }\r\n\r\n        if (\"value\" in actualChild) {\r\n          if (actualChild.value !== null)\r\n            throw new SyntaxError(this.getErrorMessage(actualToken));\r\n          (actualChild as any).value = branch;\r\n        } else actualChild.properties.push(branch as any);\r\n      };\r\n\r\n      if (\r\n        actualToken.type === \"TRUE_BOOLEAN\" ||\r\n        actualToken.type === \"FALSE_BOOLEAN\"\r\n      ) {\r\n        addASTBranch(this.appendBoolean(actualToken));\r\n      } else if (actualToken.type === \"NULL\") {\r\n        addASTBranch(this.appendNullValue(actualToken));\r\n      } else if (actualToken.type === \"NUMBER\") {\r\n        addASTBranch(this.appendNumber(actualToken));\r\n      } else if (actualToken.type === \"STRING\") {\r\n        if (actualChild.type === \"OBJECT\") {\r\n          const child = this.appendKey(actualToken);\r\n          addASTBranch(child);\r\n          childrens.push(child);\r\n        } else addASTBranch(this.appendString(actualToken));\r\n      } else if (actualToken.type === \"START_BRACKET\") {\r\n        const child = this.appendArray(actualToken);\r\n        addASTBranch(child);\r\n        childrens.push(child);\r\n      } else if (actualToken.type === \"START_BRACE\") {\r\n        const child = this.appendObject(actualToken);\r\n        addASTBranch(child);\r\n        childrens.push(child);\r\n      } else if (actualToken.type === \"END_BRACKET\") {\r\n        if (\r\n          lastScannedToken?.type === \"COMA\" ||\r\n          lastScannedToken?.type === \"COLON\"\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n\r\n        if (actualChild.type !== \"ARRAY\")\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        childrens.pop();\r\n      } else if (actualToken.type === \"END_BRACE\") {\r\n        if (\r\n          lastScannedToken?.type === \"COMA\" ||\r\n          lastScannedToken?.type === \"COLON\"\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n\r\n        if (actualChild.type === \"OBJECT_KEY\") childrens.pop();\r\n\r\n        if (childrens[childrens.length - 1].type !== \"OBJECT\")\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        childrens.pop();\r\n      } else if (actualToken.type === \"COMA\") {\r\n        if (\r\n          lastScannedToken?.type === \"COMA\" ||\r\n          lastScannedToken?.type === \"COLON\"\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        if (actualChild.type !== \"OBJECT_KEY\" && actualChild.type !== \"ARRAY\")\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        if (\r\n          actualChild.type === \"OBJECT_KEY\" &&\r\n          (actualChild as any).value === null\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        if (actualChild.type === \"OBJECT_KEY\") childrens.pop();\r\n      } else if (actualToken.type === \"COLON\") {\r\n        if (\r\n          lastScannedToken?.type !== \"STRING\" ||\r\n          actualChild.type !== \"OBJECT_KEY\" ||\r\n          (actualChild as any).value !== null\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n      }\r\n\r\n      if (actualToken.type !== \"WHITE_SPACE\") lastScannedToken = actualToken;\r\n    }\r\n\r\n    //Last children should be the tree\r\n    if (childrens.length !== 1)\r\n      throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n\r\n    return tree;\r\n  }\r\n}\r\n\r\nexport default ASTBuilder;\r\n","import type TokenizerResult from \"../types/tokenizerResult\";\r\n\r\ntype Tokens = {\r\n  [key: string]: RegExp;\r\n};\r\n\r\ntype MatcherResult = {\r\n  type: string;\r\n  wordLength: number;\r\n};\r\n\r\ntype Options = {\r\n  tokens?: Tokens;\r\n  defaultType?: string;\r\n  callback?: (token: TokenizerResult) => TokenizerResult;\r\n  concatDefaultType?: boolean;\r\n};\r\n\r\nconst defaultOptions: Options = {\r\n  tokens: {},\r\n  defaultType: \"UNKNOWN\",\r\n  concatDefaultType: true,\r\n  callback: (token) => token,\r\n};\r\n\r\n/**\r\n * Tokenize any string with given tokens\r\n */\r\nclass Tokenizer {\r\n  private options: Options = {};\r\n\r\n  constructor(options: Options = {}) {\r\n    this.options = Object.assign({}, defaultOptions, options);\r\n  }\r\n\r\n  /**\r\n   * Set the default type if no token was match\r\n   * Default: UNKNOWN\r\n   * @param type\r\n   */\r\n  setDefaultType(type: string) {\r\n    this.options.defaultType = type;\r\n  }\r\n\r\n  /**\r\n   * Get the default type if no token was match\r\n   * @returns\r\n   */\r\n  getDefaultType() {\r\n    return this.options.defaultType;\r\n  }\r\n\r\n  /**\r\n   * Get the list registered of the tokens\r\n   * @returns\r\n   */\r\n  getTokens() {\r\n    return this.options.tokens;\r\n  }\r\n\r\n  /**\r\n   * Add a new token to match\r\n   * @param type\r\n   * @param value\r\n   */\r\n  addToken(type: string, value: RegExp) {\r\n    this.options.tokens[type] = value;\r\n  }\r\n\r\n  /**\r\n   * Set the callback function called on each new token\r\n   * @param callback\r\n   */\r\n  setCallback(callback: Options[\"callback\"]) {\r\n    this.options.callback = callback;\r\n  }\r\n\r\n  /**\r\n   * Check if a given token match the start of the string\r\n   * @param str\r\n   * @param type\r\n   * @param value\r\n   * @returns\r\n   */\r\n  private matcher(str: string, type: string, value: RegExp): MatcherResult {\r\n    value.lastIndex = 0;\r\n    const match = value.exec(str);\r\n    if (!match || match.index !== 0) {\r\n      return { type: this.options.defaultType, wordLength: 1 };\r\n    }\r\n    return {\r\n      type,\r\n      wordLength: match[0].length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Tokenize a string\r\n   * @param str\r\n   * @returns\r\n   */\r\n  tokenize(str: string): TokenizerResult[] {\r\n    const tokens: TokenizerResult[] = [];\r\n    const lines = str.split(/\\n/g);\r\n\r\n    let totalCharDone = 0;\r\n    for (let startLine = 0; startLine < lines.length; ++startLine) {\r\n      const line = lines[startLine];\r\n\r\n      for (let startColumn = 0; startColumn < line.length; ++startColumn) {\r\n        const charIndex = startColumn + totalCharDone;\r\n\r\n        let result = null;\r\n        for (const [type, value] of Object.entries(this.options.tokens)) {\r\n          result = this.matcher(\r\n            str.substring(charIndex, str.length),\r\n            type,\r\n            value\r\n          );\r\n          if (result.type !== this.options.defaultType) break;\r\n        }\r\n\r\n        const matchedSentence = str.substring(\r\n          charIndex,\r\n          charIndex + result.wordLength\r\n        );\r\n        const matchedSentenceLinesNumber =\r\n          matchedSentence.match(/\\n/g)?.length ?? 0;\r\n        const token = this.options.callback({\r\n          type: result.type,\r\n          value: matchedSentence,\r\n          startLine,\r\n          startColumn,\r\n          endLine: startLine + matchedSentenceLinesNumber,\r\n          endColumn: startColumn + result.wordLength - 1, // -1 because we don't want the next char but the last letter of the token value\r\n        });\r\n        if (\r\n          this.options.concatDefaultType &&\r\n          token.type === this.options.defaultType &&\r\n          tokens.length !== 0 &&\r\n          tokens[tokens.length - 1].type === this.options.defaultType\r\n        ) {\r\n          const lastToken = tokens[tokens.length - 1];\r\n          lastToken.value += token.value;\r\n          lastToken.endColumn = token.endColumn;\r\n          lastToken.endLine = token.endLine;\r\n        } else tokens.push(token);\r\n        startColumn += result.wordLength - 1;\r\n      }\r\n\r\n      totalCharDone += line.length + 1; // +1 because the \\n have a length of 1 and is removed by the split\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n}\r\n\r\nexport default Tokenizer;\r\n","import type { ASTArray, ASTObject, ASTResult, ASTSimple } from \"../types/ast\";\r\nimport type {\r\n  JSONArray,\r\n  JSONObject,\r\n  JSONResult,\r\n  JSONPrimitif,\r\n} from \"../types/json\";\r\nimport ASTBuilder from \"./astBuilder\";\r\nimport Tokenizer from \"./tokenizer\";\r\n\r\nconst TOKENS = {\r\n  STRING: /(\")(?:\\\\\\1|.)*?\\1/,\r\n  NUMBER: /\\d+(?:\\.\\d+)?/,\r\n  WHITE_SPACE: /\\s+/,\r\n  COMA: /,/,\r\n  COLON: /:/,\r\n  TRUE_BOOLEAN: /true/,\r\n  FALSE_BOOLEAN: /false/,\r\n  NULL: /null/,\r\n  START_BRACKET: /\\[/,\r\n  END_BRACKET: /\\]/,\r\n  START_BRACE: /\\{/,\r\n  END_BRACE: /\\}/,\r\n} as const;\r\n\r\n/**\r\n * JSON parser for a given string\r\n */\r\nclass Parser {\r\n  private tokenizer = new Tokenizer({ tokens: TOKENS });\r\n  private astBuilder = new ASTBuilder();\r\n\r\n  constructor() {\r\n    /* We handle directly during the tokenizer the error if we have an UNKNOWN property */\r\n    this.tokenizer.setCallback((token) => {\r\n      if (token.type === \"UNKNOWN\")\r\n        throw new SyntaxError(this.astBuilder.getErrorMessage(token));\r\n      return token;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Parse a JSON string and return the object\r\n   * @param str\r\n   * @returns\r\n   */\r\n  parse(str: string | null | boolean | number): JSONResult {\r\n    str = String(str);\r\n    const tokens = this.tokenizer.tokenize(str);\r\n    const ast = this.astBuilder.buildAST(tokens);\r\n    return this.parseASTBranch(ast.value);\r\n  }\r\n\r\n  private parseASTBranch(astBranch: ASTResult[\"value\"]): JSONResult {\r\n    if (astBranch.type === \"OBJECT\") {\r\n      return this.parseObject(astBranch);\r\n    }\r\n\r\n    if (astBranch.type === \"ARRAY\") {\r\n      return this.parseArray(astBranch);\r\n    }\r\n\r\n    return this.parsePrimitif(astBranch);\r\n  }\r\n\r\n  private parseArray(astBranch: ASTArray): JSONArray {\r\n    const json: JSONArray = [];\r\n    for (const property of astBranch.properties) {\r\n      json.push(this.parseASTBranch(property));\r\n    }\r\n    return json;\r\n  }\r\n\r\n  private parseObject(astBranch: ASTObject): JSONObject {\r\n    const json: JSONObject = {};\r\n    for (const property of astBranch.properties) {\r\n      json[property.name] = this.parseASTBranch(property.value);\r\n    }\r\n    return json;\r\n  }\r\n\r\n  private parsePrimitif(astBranch: ASTSimple): JSONPrimitif {\r\n    return astBranch.value;\r\n  }\r\n}\r\n\r\nexport default Parser;\r\n","import Parser from \"./core/parser\";\r\n\r\nconst parser = new Parser();\r\n\r\nexport default parser.parse.bind(parser) as Parser[\"parse\"];\r\n"],"names":["ASTBuilder","getErrorMessage","token","value","startLine","startColumn","formatStr","str","content","substring","length","replace","_","char","appendBoolean","type","appendNullValue","appendString","this","appendArray","properties","appendObject","appendNumber","Number","appendKey","name","buildAST","tokens","tree","childrens","lastScannedToken","i","actualToken","actualChild","addASTBranch","branch","SyntaxError","push","child","pop","defaultOptions","defaultType","concatDefaultType","callback","Tokenizer","constructor","options","Object","assign","setDefaultType","getDefaultType","getTokens","addToken","setCallback","matcher","lastIndex","match","exec","index","wordLength","tokenize","lines","split","totalCharDone","line","charIndex","result","entries","matchedSentence","matchedSentenceLinesNumber","_b","_a","endLine","endColumn","lastToken","TOKENS","STRING","NUMBER","WHITE_SPACE","COMA","COLON","TRUE_BOOLEAN","FALSE_BOOLEAN","NULL","START_BRACKET","END_BRACKET","START_BRACE","END_BRACE","parser","tokenizer","astBuilder","parse","String","ast","parseASTBranch","astBranch","parseObject","parseArray","parsePrimitif","json","property","bind"],"mappings":"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"}