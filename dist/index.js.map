{"version":3,"file":"index.js","sources":["../src/core/astBuilder.ts","../src/core/tokenizer.ts","../src/core/parser.ts","../src/index.ts"],"sourcesContent":["import type {\r\n  ASTAnyValue,\r\n  ASTArray,\r\n  ASTBoolean,\r\n  ASTChildren,\r\n  ASTNull,\r\n  ASTNumber,\r\n  ASTObject,\r\n  ASTObjectKey,\r\n  ASTResult,\r\n  ASTString,\r\n} from \"../types/ast\";\r\nimport type TokenizerResult from \"../types/tokenizerResult\";\r\n\r\nclass ASTBuilder {\r\n  /**\r\n   * Return the error message for a given token\r\n   * @param token\r\n   * @returns\r\n   */\r\n  private getErrorMessage(token: TokenizerResult) {\r\n    return `\"${token.value}\" is not valid JSON\\nline: ${token.startLine}, column: ${token.startColumn}`;\r\n  }\r\n\r\n  /**\r\n   * Format a string token to remove useless quotes and parse unicode\r\n   * @param str\r\n   * @returns\r\n   */\r\n  private formatStr(str: string) {\r\n    return str\r\n      .substring(1, str.length - 1) //We remove useless quotes\r\n      .replace(/\\\\\\\\/g, \"\\\\\"); //TODO: Fixe this shit \\\\n -> \\n\r\n  }\r\n\r\n  private appendBoolean(token: TokenizerResult): ASTBoolean {\r\n    return {\r\n      type: \"BOOLEAN\",\r\n      value: token.type === \"TRUE_BOOLEAN\" ? true : false,\r\n    };\r\n  }\r\n\r\n  private appendNullValue(token: TokenizerResult): ASTNull {\r\n    return {\r\n      type: \"NULL_VALUE\",\r\n      value: null as null,\r\n    };\r\n  }\r\n\r\n  private appendString(token: TokenizerResult): ASTString {\r\n    return {\r\n      type: \"STRING\",\r\n      value: this.formatStr(token.value),\r\n    };\r\n  }\r\n\r\n  private appendArray(token: TokenizerResult): ASTArray {\r\n    return {\r\n      type: \"ARRAY\",\r\n      properties: [],\r\n    };\r\n  }\r\n\r\n  private appendObject(token: TokenizerResult): ASTObject {\r\n    return {\r\n      type: \"OBJECT\",\r\n      properties: [],\r\n    };\r\n  }\r\n\r\n  private appendNumber(token: TokenizerResult): ASTNumber {\r\n    return {\r\n      type: \"NUMBER\",\r\n      value: Number(token.value),\r\n    };\r\n  }\r\n\r\n  private appendKey(token: TokenizerResult): ASTObjectKey {\r\n    return {\r\n      type: \"OBJECT_KEY\",\r\n      name: this.formatStr(token.value),\r\n      value: null,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build the AST for given tokens\r\n   * @param tokens\r\n   * @returns\r\n   */\r\n  buildAST(tokens: TokenizerResult[]) {\r\n    const tree: ASTResult = { type: \"JSON\", value: null };\r\n    const childrens: ASTChildren[] = [tree];\r\n\r\n    let lastScannedToken = null;\r\n    for (let i = 0; i < tokens.length; ++i) {\r\n      const actualToken = tokens[i];\r\n      const actualChild = childrens[childrens.length - 1];\r\n\r\n      const addASTBranch = (branch: ASTAnyValue) => {\r\n        if (\"value\" in actualChild) {\r\n          if (actualChild.value !== null)\r\n            throw new SyntaxError(this.getErrorMessage(actualToken));\r\n          (actualChild as any).value = branch;\r\n        } else actualChild.properties.push(branch as any);\r\n      };\r\n\r\n      if (actualToken.type === \"UNKNOWN\") {\r\n        throw new SyntaxError(this.getErrorMessage(actualToken));\r\n      } else if (\r\n        actualToken.type === \"TRUE_BOOLEAN\" ||\r\n        actualToken.type === \"FALSE_BOOLEAN\"\r\n      ) {\r\n        addASTBranch(this.appendBoolean(actualToken));\r\n      } else if (actualToken.type === \"NULL\") {\r\n        addASTBranch(this.appendNullValue(actualToken));\r\n      } else if (actualToken.type === \"NUMBER\") {\r\n        addASTBranch(this.appendNumber(actualToken));\r\n      } else if (actualToken.type === \"STRING\") {\r\n        if (actualChild.type === \"OBJECT\") {\r\n          const child = this.appendKey(actualToken);\r\n          addASTBranch(child);\r\n          childrens.push(child);\r\n        } else addASTBranch(this.appendString(actualToken));\r\n      } else if (actualToken.type === \"START_BRACKET\") {\r\n        const child = this.appendArray(actualToken);\r\n        addASTBranch(child);\r\n        childrens.push(child);\r\n      } else if (actualToken.type === \"START_BRACE\") {\r\n        const child = this.appendObject(actualToken);\r\n        addASTBranch(child);\r\n        childrens.push(child);\r\n      } else if (actualToken.type === \"END_BRACKET\") {\r\n        if (\r\n          lastScannedToken.type === \"COMA\" ||\r\n          lastScannedToken.type === \"COLON\"\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n\r\n        if (actualChild.type !== \"ARRAY\")\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        childrens.pop();\r\n      } else if (actualToken.type === \"END_BRACE\") {\r\n        if (\r\n          lastScannedToken.type === \"COMA\" ||\r\n          lastScannedToken.type === \"COLON\"\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n\r\n        if (actualChild.type === \"OBJECT_KEY\") childrens.pop();\r\n\r\n        if (childrens[childrens.length - 1].type !== \"OBJECT\")\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        childrens.pop();\r\n      } else if (actualToken.type === \"COMA\") {\r\n        if (actualChild.type !== \"OBJECT_KEY\" && actualChild.type !== \"ARRAY\")\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        if (\r\n          actualChild.type === \"OBJECT_KEY\" &&\r\n          (actualChild as any).value === null\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        if (actualChild.type === \"OBJECT_KEY\") childrens.pop();\r\n      } else if (actualToken.type === \"COLON\") {\r\n        if (\r\n          actualChild.type !== \"OBJECT_KEY\" ||\r\n          (actualChild as any).value !== null\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n      }\r\n\r\n      if (actualToken.type !== \"WHITE_SPACE\") lastScannedToken = actualToken;\r\n    }\r\n\r\n    //Last children should be the tree\r\n    if (childrens.length !== 1)\r\n      throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n\r\n    return tree;\r\n  }\r\n}\r\n\r\nexport default ASTBuilder;\r\n","import type TokenizerResult from \"../types/tokenizerResult\";\r\n\r\ntype Tokens = {\r\n  [key: string]: RegExp;\r\n};\r\n\r\ntype MatcherResult = {\r\n  type: string;\r\n  wordLength: number;\r\n};\r\n\r\n/**\r\n * Tokenize any string with given tokens\r\n */\r\nclass Tokenizer {\r\n  private defaultType = \"UNKNOWN\";\r\n\r\n  constructor(private tokens: Tokens = {}) {}\r\n\r\n  /**\r\n   * Set the default type if no token was match\r\n   * Default: UNKNOWN\r\n   * @param type\r\n   */\r\n  setDefaultType(type: string) {\r\n    this.defaultType = type;\r\n  }\r\n\r\n  /**\r\n   * Get the default type if no token was match\r\n   * @returns\r\n   */\r\n  getDefaultType() {\r\n    return this.defaultType;\r\n  }\r\n\r\n  /**\r\n   * Get the list registered of the tokens\r\n   * @returns\r\n   */\r\n  getTokens() {\r\n    return this.tokens;\r\n  }\r\n\r\n  /**\r\n   * Add a new token to match\r\n   * @param type\r\n   * @param value\r\n   */\r\n  addToken(type: string, value: RegExp) {\r\n    this.tokens[type] = value;\r\n  }\r\n\r\n  /**\r\n   * Check if a given token match the start of the string\r\n   * @param str\r\n   * @param type\r\n   * @param value\r\n   * @returns\r\n   */\r\n  private matcher(str: string, type: string, value: RegExp): MatcherResult {\r\n    value.lastIndex = 0;\r\n    const match = value.exec(str);\r\n    if (!match || match.index !== 0) {\r\n      return { type: this.defaultType, wordLength: 1 };\r\n    }\r\n    return {\r\n      type,\r\n      wordLength: match[0].length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Tokenize a string\r\n   * @param str\r\n   * @returns\r\n   */\r\n  tokenize(str: string): TokenizerResult[] {\r\n    const tokens = [];\r\n    const lines = str.split(/(\\n)/g);\r\n\r\n    for (let startLine = 0; startLine < lines.length; ++startLine) {\r\n      const line = lines[startLine];\r\n\r\n      for (let startColumn = 0; startColumn < line.length; ++startColumn) {\r\n        const charIndex = (startLine + 1) * (startColumn + 1) - 1;\r\n\r\n        let result = null;\r\n        for (const [type, value] of Object.entries(this.tokens)) {\r\n          result = this.matcher(\r\n            str.substring(charIndex, str.length),\r\n            type,\r\n            value\r\n          );\r\n          if (result.type !== this.defaultType) break;\r\n        }\r\n\r\n        tokens.push({\r\n          type: result.type,\r\n          value: str.substring(charIndex, charIndex + result.wordLength),\r\n          startLine,\r\n          startColumn,\r\n          endLine: startLine,\r\n          endColumn: startColumn + result.wordLength - 1,\r\n        });\r\n        startColumn += result.wordLength - 1;\r\n      }\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n}\r\n\r\nexport default Tokenizer;\r\n","import type { ASTArray, ASTObject, ASTResult, ASTSimple } from \"../types/ast\";\r\nimport type {\r\n  JSONArray,\r\n  JSONObject,\r\n  JSONResult,\r\n  JSONPrimitif,\r\n} from \"../types/json\";\r\nimport ASTBuilder from \"./astBuilder\";\r\nimport Tokenizer from \"./tokenizer\";\r\n\r\nconst TOKENS = {\r\n  STRING: /(\")(?:\\\\\\1|.)*?\\1/,\r\n  NUMBER: /\\d+(?:.\\d+)?/,\r\n  WHITE_SPACE: /\\s+/,\r\n  COMA: /,/,\r\n  COLON: /:/,\r\n  TRUE_BOOLEAN: /true/,\r\n  FALSE_BOOLEAN: /false/,\r\n  NULL: /null/,\r\n  START_BRACKET: /\\[/,\r\n  END_BRACKET: /\\]/,\r\n  START_BRACE: /\\{/,\r\n  END_BRACE: /\\}/,\r\n} as const;\r\n\r\n/**\r\n * JSON parser for a given string\r\n */\r\nclass Parser {\r\n  private tokenizer = new Tokenizer(TOKENS);\r\n  private astBuilder = new ASTBuilder();\r\n\r\n  /**\r\n   * Parse a JSON string and return the object\r\n   * @param str\r\n   * @returns\r\n   */\r\n  parse(str: string): JSONResult {\r\n    str = String(str);\r\n    const tokens = this.tokenizer.tokenize(str);\r\n    const ast = this.astBuilder.buildAST(tokens);\r\n    return this.parseASTBranch(ast.value);\r\n  }\r\n\r\n  private parseASTBranch(astBranch: ASTResult[\"value\"]): JSONResult {\r\n    if (astBranch.type === \"OBJECT\") {\r\n      return this.parseObject(astBranch);\r\n    }\r\n\r\n    if (astBranch.type === \"ARRAY\") {\r\n      return this.parseArray(astBranch);\r\n    }\r\n\r\n    return this.parsePrimitif(astBranch);\r\n  }\r\n\r\n  private parseArray(astBranch: ASTArray): JSONArray {\r\n    const json: JSONArray = [];\r\n    for (const property of astBranch.properties) {\r\n      json.push(this.parseASTBranch(property));\r\n    }\r\n    return json;\r\n  }\r\n\r\n  private parseObject(astBranch: ASTObject): JSONObject {\r\n    const json: JSONObject = {};\r\n    for (const property of astBranch.properties) {\r\n      json[property.name] = this.parseASTBranch(property.value);\r\n    }\r\n    return json;\r\n  }\r\n\r\n  private parsePrimitif(astBranch: ASTSimple): JSONPrimitif {\r\n    return astBranch.value;\r\n  }\r\n}\r\n\r\nexport default Parser;\r\n","import Parser from \"./core/parser\";\r\n\r\nconst parser = new Parser();\r\n\r\nexport default parser.parse.bind(parser) as Parser[\"parse\"];\r\n"],"names":["ASTBuilder","getErrorMessage","token","value","startLine","startColumn","formatStr","str","substring","length","replace","appendBoolean","type","appendNullValue","appendString","this","appendArray","properties","appendObject","appendNumber","Number","appendKey","name","buildAST","tokens","tree","childrens","lastScannedToken","i","actualToken","actualChild","addASTBranch","branch","SyntaxError","push","child","pop","Tokenizer","constructor","defaultType","setDefaultType","getDefaultType","getTokens","addToken","matcher","lastIndex","match","exec","index","wordLength","tokenize","lines","split","line","charIndex","result","Object","entries","endLine","endColumn","TOKENS","STRING","NUMBER","WHITE_SPACE","COMA","COLON","TRUE_BOOLEAN","FALSE_BOOLEAN","NULL","START_BRACKET","END_BRACKET","START_BRACE","END_BRACE","parser","tokenizer","astBuilder","parse","String","ast","parseASTBranch","astBranch","parseObject","parseArray","parsePrimitif","json","property","bind"],"mappings":"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"}