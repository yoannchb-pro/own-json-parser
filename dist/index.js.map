{"version":3,"file":"index.js","sources":["../src/core/astBuilder.ts","../src/core/tokenizer.ts","../src/core/parser.ts","../src/index.ts"],"sourcesContent":["import type {\r\n  ASTAnyValue,\r\n  ASTArray,\r\n  ASTBoolean,\r\n  ASTChildren,\r\n  ASTNull,\r\n  ASTNumber,\r\n  ASTObject,\r\n  ASTObjectKey,\r\n  ASTResult,\r\n  ASTString,\r\n} from \"../types/ast\";\r\nimport type TokenizerResult from \"../types/tokenizerResult\";\r\n\r\n/**\r\n * Unraw a string to transform for example \\\\n to \\n\r\n * @param rawString\r\n * @returns\r\n */\r\nfunction unrawString(rawString: string) {\r\n  return rawString.replace(/\\\\(.)/g, function (_, char) {\r\n    if (char === \"n\") return \"\\n\";\r\n    if (char === \"r\") return \"\\r\";\r\n    if (char === \"t\") return \"\\t\";\r\n    if (char === \"b\") return \"\\b\";\r\n    if (char === \"f\") return \"\\f\";\r\n    if (char === \"v\") return \"\\v\";\r\n    return char;\r\n  });\r\n}\r\n\r\nclass ASTBuilder {\r\n  /**\r\n   * Return the error message for a given token\r\n   * @param token\r\n   * @returns\r\n   */\r\n  getErrorMessage(token: TokenizerResult) {\r\n    return `\"${token.value}\" is not valid JSON\\nline: ${token.startLine}, column: ${token.startColumn}`;\r\n  }\r\n\r\n  /**\r\n   * Format a string token to remove useless quotes and parse unicode\r\n   * @param str\r\n   * @returns\r\n   */\r\n  private formatStr(str: string) {\r\n    const content = str.substring(1, str.length - 1); //We remove useless quotes\r\n    return unrawString(content); // turn \\\\n into \\n ...\r\n  }\r\n\r\n  private appendBoolean(token: TokenizerResult): ASTBoolean {\r\n    return {\r\n      type: \"BOOLEAN\",\r\n      value: token.type === \"TRUE_BOOLEAN\" ? true : false,\r\n    };\r\n  }\r\n\r\n  private appendNullValue(token: TokenizerResult): ASTNull {\r\n    return {\r\n      type: \"NULL_VALUE\",\r\n      value: null as null,\r\n    };\r\n  }\r\n\r\n  private appendString(token: TokenizerResult): ASTString {\r\n    return {\r\n      type: \"STRING\",\r\n      value: this.formatStr(token.value),\r\n    };\r\n  }\r\n\r\n  private appendArray(token: TokenizerResult): ASTArray {\r\n    return {\r\n      type: \"ARRAY\",\r\n      properties: [],\r\n    };\r\n  }\r\n\r\n  private appendObject(token: TokenizerResult): ASTObject {\r\n    return {\r\n      type: \"OBJECT\",\r\n      properties: [],\r\n    };\r\n  }\r\n\r\n  private appendNumber(token: TokenizerResult): ASTNumber {\r\n    return {\r\n      type: \"NUMBER\",\r\n      value: Number(token.value),\r\n    };\r\n  }\r\n\r\n  private appendKey(token: TokenizerResult): ASTObjectKey {\r\n    return {\r\n      type: \"OBJECT_KEY\",\r\n      name: this.formatStr(token.value),\r\n      value: null,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build the AST for given tokens\r\n   * @param tokens\r\n   * @returns\r\n   */\r\n  buildAST(tokens: TokenizerResult[]) {\r\n    const tree: ASTResult = { type: \"JSON\", value: null };\r\n    const childrens: ASTChildren[] = [tree];\r\n\r\n    let lastScannedToken: TokenizerResult = null;\r\n    for (let i = 0; i < tokens.length; ++i) {\r\n      const actualToken = tokens[i];\r\n      const actualChild = childrens[childrens.length - 1];\r\n\r\n      const addASTBranch = (branch: ASTAnyValue) => {\r\n        if (\r\n          actualChild.type === \"ARRAY\" &&\r\n          lastScannedToken !== null &&\r\n          lastScannedToken.type !== \"START_BRACKET\" &&\r\n          lastScannedToken.type !== \"COMA\"\r\n        ) {\r\n          throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n        }\r\n\r\n        if (actualChild.type === \"OBJECT\" && branch.type !== \"OBJECT_KEY\") {\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n        }\r\n\r\n        if (\"value\" in actualChild) {\r\n          if (actualChild.value !== null)\r\n            throw new SyntaxError(this.getErrorMessage(actualToken));\r\n          (actualChild as any).value = branch;\r\n        } else actualChild.properties.push(branch as any);\r\n      };\r\n\r\n      if (\r\n        actualToken.type === \"TRUE_BOOLEAN\" ||\r\n        actualToken.type === \"FALSE_BOOLEAN\"\r\n      ) {\r\n        addASTBranch(this.appendBoolean(actualToken));\r\n      } else if (actualToken.type === \"NULL\") {\r\n        addASTBranch(this.appendNullValue(actualToken));\r\n      } else if (actualToken.type === \"NUMBER\") {\r\n        addASTBranch(this.appendNumber(actualToken));\r\n      } else if (actualToken.type === \"STRING\") {\r\n        if (actualChild.type === \"OBJECT\") {\r\n          const child = this.appendKey(actualToken);\r\n          addASTBranch(child);\r\n          childrens.push(child);\r\n        } else addASTBranch(this.appendString(actualToken));\r\n      } else if (actualToken.type === \"START_BRACKET\") {\r\n        const child = this.appendArray(actualToken);\r\n        addASTBranch(child);\r\n        childrens.push(child);\r\n      } else if (actualToken.type === \"START_BRACE\") {\r\n        const child = this.appendObject(actualToken);\r\n        addASTBranch(child);\r\n        childrens.push(child);\r\n      } else if (actualToken.type === \"END_BRACKET\") {\r\n        if (\r\n          lastScannedToken?.type === \"COMA\" ||\r\n          lastScannedToken?.type === \"COLON\"\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n\r\n        if (actualChild.type !== \"ARRAY\")\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        childrens.pop();\r\n      } else if (actualToken.type === \"END_BRACE\") {\r\n        if (\r\n          lastScannedToken?.type === \"COMA\" ||\r\n          lastScannedToken?.type === \"COLON\"\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n\r\n        if (actualChild.type === \"OBJECT_KEY\") childrens.pop();\r\n\r\n        if (childrens[childrens.length - 1].type !== \"OBJECT\")\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        childrens.pop();\r\n      } else if (actualToken.type === \"COMA\") {\r\n        if (\r\n          lastScannedToken?.type === \"COMA\" ||\r\n          lastScannedToken?.type === \"COLON\"\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        if (actualChild.type !== \"OBJECT_KEY\" && actualChild.type !== \"ARRAY\")\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        if (\r\n          actualChild.type === \"OBJECT_KEY\" &&\r\n          (actualChild as any).value === null\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n\r\n        if (actualChild.type === \"OBJECT_KEY\") childrens.pop();\r\n      } else if (actualToken.type === \"COLON\") {\r\n        if (\r\n          lastScannedToken?.type !== \"STRING\" ||\r\n          actualChild.type !== \"OBJECT_KEY\" ||\r\n          (actualChild as any).value !== null\r\n        )\r\n          throw new SyntaxError(this.getErrorMessage(actualToken));\r\n      }\r\n\r\n      if (actualToken.type !== \"WHITE_SPACE\") lastScannedToken = actualToken;\r\n    }\r\n\r\n    //Last children should be the tree\r\n    if (childrens.length !== 1)\r\n      throw new SyntaxError(this.getErrorMessage(lastScannedToken));\r\n\r\n    return tree;\r\n  }\r\n}\r\n\r\nexport default ASTBuilder;\r\n","type MatcherResult<T extends Tokens, D extends string, A extends boolean> = {\r\n  type: TokenType<T, D, A>;\r\n  value: string;\r\n  groups?: Record<string, string>;\r\n  index: number;\r\n};\r\n\r\ntype Tokens = {\r\n  [key: string]: RegExp;\r\n};\r\n\r\ntype TokenType<T extends Tokens, D extends string, A extends boolean> =\r\n  | keyof T\r\n  | (A extends true ? D | Omit<string, keyof T | D> : D);\r\n\r\ntype Token<T extends Tokens, D extends string, A extends boolean> = {\r\n  type: TokenType<T, D, A>;\r\n  value: string;\r\n  groups?: Record<string, string>;\r\n  startLine: number;\r\n  endLine: number;\r\n  startColumn: number;\r\n  endColumn: number;\r\n};\r\n\r\ntype Options<T extends Tokens, D extends string, A extends boolean> = {\r\n  tokens: T;\r\n  defaultType: D;\r\n  prioritize?: boolean;\r\n  callback?: (\r\n    token: Token<T, D, A>,\r\n    prevTokens: Token<T, D, A>[]\r\n  ) => Token<T, D, A> | null;\r\n  concatDefaultType?: boolean;\r\n  authorizeAdditionalTokens?: A;\r\n};\r\n\r\nconst defaultOptions = {\r\n  defaultType: \"UNKNOWN\",\r\n  concatDefaultType: true,\r\n} as const satisfies Partial<Options<{}, \"UNKNOWN\", false>>;\r\n\r\ntype ConstructorOptions<\r\n  T extends Tokens,\r\n  D extends string,\r\n  A extends boolean\r\n> = Omit<Options<T, D, A>, keyof typeof defaultOptions> &\r\n  Partial<Pick<Options<T, D, A>, keyof typeof defaultOptions>>;\r\n\r\n/**\r\n * Tokenize any string with given tokens\r\n */\r\nclass Tokenizer<\r\n  T extends Tokens,\r\n  D extends string = \"UNKNOWN\",\r\n  A extends boolean = false\r\n> {\r\n  public static BUILT_IN_RULES = {\r\n    WORD: /\\w+/,\r\n    NUMBER: /\\d+(?:\\.\\d+)?/,\r\n\r\n    ONE_LINE_COMMENT: /\\/\\/.*/,\r\n    MULTIPLE_LINE_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\r\n\r\n    STRING: /(\"|'|`)(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    DOUBLE_QUOTE_STRING: /(\")(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    SINGLE_QUOTE_STRING: /(')(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    GRAVE_ACCENT_STRING: /(`)(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n\r\n    WHITE_SPACES: /\\s+/,\r\n    NEW_LINES: /\\n+/,\r\n  } as const satisfies Record<string, RegExp>;\r\n  private options: Options<T, D, A>;\r\n\r\n  constructor(_options: ConstructorOptions<T, D, A>) {\r\n    if (!_options || !_options.tokens)\r\n      throw new Error('Invalide options: \"tokens\" is required');\r\n    this.options = Object.assign({}, defaultOptions, _options);\r\n  }\r\n\r\n  /**\r\n   * Get the default type if no token was match\r\n   * @returns\r\n   */\r\n  getDefaultType(): D {\r\n    return this.options.defaultType;\r\n  }\r\n\r\n  /**\r\n   * Get the list registered of the tokens\r\n   * @returns\r\n   */\r\n  getTokens(): T {\r\n    return this.options.tokens;\r\n  }\r\n\r\n  /**\r\n   * Get the list of tokens name\r\n   * @returns\r\n   */\r\n  getTokensName(): (keyof T | D)[] {\r\n    return [...Object.keys(this.options.tokens), this.getDefaultType()];\r\n  }\r\n\r\n  /**\r\n   * Check if a given token match the start of the string\r\n   * @param str\r\n   * @param type\r\n   * @param reg\r\n   * @returns\r\n   */\r\n  private matcher(\r\n    str: string,\r\n    type: string,\r\n    reg: RegExp\r\n  ): MatcherResult<T, D, A> | null {\r\n    reg.lastIndex = 0;\r\n    const match = reg.exec(str);\r\n\r\n    if (!match) return null;\r\n\r\n    return {\r\n      type,\r\n      value: match[0],\r\n      groups: match.groups,\r\n      index: match.index,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Tokenize a string\r\n   * @param str\r\n   * @returns\r\n   */\r\n  tokenize(str: string): Token<T, D, A>[] {\r\n    if (typeof str !== \"string\") return [];\r\n\r\n    const tokens: Token<T, D, A>[] = [];\r\n\r\n    const defaultType = this.getDefaultType();\r\n    const concatDefaultType = this.options.concatDefaultType;\r\n    const tokensList = this.options.tokens;\r\n\r\n    for (let charIndex = 0; charIndex < str.length; ++charIndex) {\r\n      const strToDo = str.substring(charIndex, str.length);\r\n      const strDone = str.substring(0, charIndex);\r\n\r\n      const defaultResult: MatcherResult<T, D, A> = {\r\n        type: defaultType,\r\n        value: strToDo.charAt(0),\r\n        index: 0,\r\n      };\r\n      let result = defaultResult;\r\n\r\n      // Check if any regex is matching\r\n      const reversedTokens = Object.entries(tokensList).reverse(); // For prioritization\r\n      for (const [type, reg] of reversedTokens) {\r\n        const match = this.matcher(strToDo, type, reg);\r\n        if (match !== null) {\r\n          if (match.index === 0) {\r\n            result = match; // If the index is 0 we found the token\r\n          } else if (\r\n            this.options.prioritize &&\r\n            result !== defaultResult &&\r\n            result.value.length > match.index // Check if the current matching token that have a bigger priority, than the last one, don't have conflict with the last matched token\r\n          ) {\r\n            result = defaultResult;\r\n          }\r\n        }\r\n      }\r\n\r\n      const splittedValueOnLines = result.value.split(/\\n/g);\r\n\r\n      const startLine = strDone.match(/\\n/g)?.length ?? 0;\r\n      const endLine = startLine + Math.max(splittedValueOnLines.length - 1, 0);\r\n      const startColumn = strDone.split(/\\n/g)?.[startLine]?.length ?? 0;\r\n      const endColumn =\r\n        splittedValueOnLines[splittedValueOnLines.length - 1].length +\r\n        (startLine === endLine ? startColumn : 0);\r\n\r\n      let token: Token<T, D, A> | null = {\r\n        type: result.type,\r\n        value: result.value,\r\n        ...(result.groups ? { groups: result.groups } : {}),\r\n        startLine,\r\n        startColumn,\r\n        endLine,\r\n        endColumn,\r\n      };\r\n\r\n      token = this.options.callback\r\n        ? this.options.callback(token, tokens)\r\n        : token;\r\n\r\n      // We update the char index based on what we have match\r\n      charIndex += result.value.length - 1;\r\n\r\n      // Check the new token returned by the callback\r\n      if (token === null) continue;\r\n      if (\r\n        !this.options.authorizeAdditionalTokens &&\r\n        !this.getTokensName().includes(token.type as keyof T | D)\r\n      ) {\r\n        throw new Error(\r\n          `Unknown token type returned by the callback: \"${\r\n            token.type as string\r\n          }\" (If you want to allow other types please set authorizeAdditionalTokens to true)`\r\n        );\r\n      }\r\n\r\n      const isTokenDefaultType = token.type === defaultType;\r\n      const needConcatenation =\r\n        concatDefaultType &&\r\n        isTokenDefaultType &&\r\n        tokens.length !== 0 &&\r\n        tokens[tokens.length - 1].type === defaultType;\r\n      if (needConcatenation) {\r\n        // Concatenation with the last token if needed\r\n        const lastToken = tokens[tokens.length - 1];\r\n        lastToken.value += token.value;\r\n        lastToken.endColumn = token.endColumn;\r\n        lastToken.endLine = token.endLine;\r\n      } else {\r\n        tokens.push(token);\r\n      }\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n}\r\n\r\nexport default Tokenizer;\r\n","import type { ASTArray, ASTObject, ASTResult, ASTSimple } from \"../types/ast\";\r\nimport type {\r\n  JSONArray,\r\n  JSONObject,\r\n  JSONResult,\r\n  JSONPrimitif,\r\n} from \"../types/json\";\r\nimport ASTBuilder from \"./astBuilder\";\r\nimport Tokenizer from \"./tokenizer\";\r\n\r\nconst TOKENS = {\r\n  STRING: /(\")(?:\\\\\\1|.)*?\\1/,\r\n  NUMBER: /\\d+(?:\\.\\d+)?/,\r\n  WHITE_SPACE: /\\s+/,\r\n  COMA: /,/,\r\n  COLON: /:/,\r\n  TRUE_BOOLEAN: /true/,\r\n  FALSE_BOOLEAN: /false/,\r\n  NULL: /null/,\r\n  START_BRACKET: /\\[/,\r\n  END_BRACKET: /\\]/,\r\n  START_BRACE: /\\{/,\r\n  END_BRACE: /\\}/,\r\n} as const;\r\n\r\n/**\r\n * JSON parser for a given string\r\n */\r\nclass Parser {\r\n  private astBuilder = new ASTBuilder();\r\n  private tokenizer = new Tokenizer({\r\n    tokens: TOKENS,\r\n    callback: (token) => {\r\n      if (token.type === \"UNKNOWN\")\r\n        throw new SyntaxError(this.astBuilder.getErrorMessage(token));\r\n      return token;\r\n    },\r\n  });\r\n\r\n  /**\r\n   * Parse a JSON string and return the object\r\n   * @param str\r\n   * @returns\r\n   */\r\n  parse(str: string | null | boolean | number): JSONResult {\r\n    str = String(str);\r\n    const tokens = this.tokenizer.tokenize(str);\r\n    const ast = this.astBuilder.buildAST(tokens);\r\n    return this.parseASTBranch(ast.value);\r\n  }\r\n\r\n  private parseASTBranch(astBranch: ASTResult[\"value\"]): JSONResult {\r\n    if (astBranch.type === \"OBJECT\") {\r\n      return this.parseObject(astBranch);\r\n    }\r\n\r\n    if (astBranch.type === \"ARRAY\") {\r\n      return this.parseArray(astBranch);\r\n    }\r\n\r\n    return this.parsePrimitif(astBranch);\r\n  }\r\n\r\n  private parseArray(astBranch: ASTArray): JSONArray {\r\n    const json: JSONArray = [];\r\n    for (const property of astBranch.properties) {\r\n      json.push(this.parseASTBranch(property));\r\n    }\r\n    return json;\r\n  }\r\n\r\n  private parseObject(astBranch: ASTObject): JSONObject {\r\n    const json: JSONObject = {};\r\n    for (const property of astBranch.properties) {\r\n      json[property.name] = this.parseASTBranch(property.value);\r\n    }\r\n    return json;\r\n  }\r\n\r\n  private parsePrimitif(astBranch: ASTSimple): JSONPrimitif {\r\n    return astBranch.value;\r\n  }\r\n}\r\n\r\nexport default Parser;\r\n","import Parser from \"./core/parser\";\r\n\r\nconst parser = new Parser();\r\nconst JSONParser = parser.parse.bind(parser);\r\n\r\nexport default JSONParser;\r\n"],"names":["ASTBuilder","getErrorMessage","token","value","startLine","startColumn","formatStr","str","content","substring","length","replace","_","char","appendBoolean","type","appendNullValue","appendString","this","appendArray","properties","appendObject","appendNumber","Number","appendKey","name","buildAST","tokens","tree","childrens","lastScannedToken","i","actualToken","actualChild","addASTBranch","branch","SyntaxError","push","child","pop","defaultOptions","defaultType","concatDefaultType","Tokenizer","constructor","_options","Error","options","Object","assign","getDefaultType","getTokens","getTokensName","keys","matcher","reg","lastIndex","match","exec","groups","index","tokenize","tokensList","charIndex","strToDo","strDone","defaultResult","charAt","result","reversedTokens","entries","reverse","prioritize","splittedValueOnLines","split","_b","_a","endLine","Math","max","_e","_c","endColumn","callback","authorizeAdditionalTokens","includes","isTokenDefaultType","lastToken","BUILT_IN_RULES","WORD","NUMBER","ONE_LINE_COMMENT","MULTIPLE_LINE_COMMENT","STRING","DOUBLE_QUOTE_STRING","SINGLE_QUOTE_STRING","GRAVE_ACCENT_STRING","WHITE_SPACES","NEW_LINES","TOKENS","WHITE_SPACE","COMA","COLON","TRUE_BOOLEAN","FALSE_BOOLEAN","NULL","START_BRACKET","END_BRACKET","START_BRACE","END_BRACE","parser","astBuilder","tokenizer","parse","String","ast","parseASTBranch","astBranch","parseObject","parseArray","parsePrimitif","json","property","bind"],"mappings":"2OA+BA,MAAMA,EAMJC,gBAAgBC,GACd,MAAO,IAAIA,EAAMC,mCAAmCD,EAAME,sBAAsBF,EAAMG,aACvF,CAOOC,UAAUC,GAChB,MAAMC,EAAUD,EAAIE,UAAU,EAAGF,EAAIG,OAAS,GAC9C,OAAmBF,EA5BJG,QAAQ,UAAU,SAAUC,EAAGC,GAC9C,MAAa,MAATA,EAAqB,KACZ,MAATA,EAAqB,KACZ,MAATA,EAAqB,KACZ,MAATA,EAAqB,KACZ,MAATA,EAAqB,KACZ,MAATA,EAAqB,KAClBA,CACT,GAqBC,CAEOC,cAAcZ,GACpB,MAAO,CACLa,KAAM,UACNZ,MAAsB,iBAAfD,EAAMa,KAEhB,CAEOC,gBAAgBd,GACtB,MAAO,CACLa,KAAM,aACNZ,MAAO,KAEV,CAEOc,aAAaf,GACnB,MAAO,CACLa,KAAM,SACNZ,MAAOe,KAAKZ,UAAUJ,EAAMC,OAE/B,CAEOgB,YAAYjB,GAClB,MAAO,CACLa,KAAM,QACNK,WAAY,GAEf,CAEOC,aAAanB,GACnB,MAAO,CACLa,KAAM,SACNK,WAAY,GAEf,CAEOE,aAAapB,GACnB,MAAO,CACLa,KAAM,SACNZ,MAAOoB,OAAOrB,EAAMC,OAEvB,CAEOqB,UAAUtB,GAChB,MAAO,CACLa,KAAM,aACNU,KAAMP,KAAKZ,UAAUJ,EAAMC,OAC3BA,MAAO,KAEV,CAODuB,SAASC,GACP,MAAMC,EAAkB,CAAEb,KAAM,OAAQZ,MAAO,MACzC0B,EAA2B,CAACD,GAElC,IAAIE,EAAoC,KACxC,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAOjB,SAAUqB,EAAG,CACtC,MAAMC,EAAcL,EAAOI,GACrBE,EAAcJ,EAAUA,EAAUnB,OAAS,GAE3CwB,EAAgBC,IACpB,GACuB,UAArBF,EAAYlB,MACS,OAArBe,GAC0B,kBAA1BA,EAAiBf,MACS,SAA1Be,EAAiBf,KAEjB,MAAM,IAAIqB,YAAYlB,KAAKjB,gBAAgB6B,IAG7C,GAAyB,WAArBG,EAAYlB,MAAqC,eAAhBoB,EAAOpB,KAC1C,MAAM,IAAIqB,YAAYlB,KAAKjB,gBAAgB+B,IAG7C,GAAI,UAAWC,EAAa,CAC1B,GAA0B,OAAtBA,EAAY9B,MACd,MAAM,IAAIiC,YAAYlB,KAAKjB,gBAAgB+B,IAC5CC,EAAoB9B,MAAQgC,CAC9B,MAAMF,EAAYb,WAAWiB,KAAKF,EAAc,EAGnD,GACuB,iBAArBH,EAAYjB,MACS,kBAArBiB,EAAYjB,KAEZmB,EAAahB,KAAKJ,cAAckB,SAC3B,GAAyB,SAArBA,EAAYjB,KACrBmB,EAAahB,KAAKF,gBAAgBgB,SAC7B,GAAyB,WAArBA,EAAYjB,KACrBmB,EAAahB,KAAKI,aAAaU,SAC1B,GAAyB,WAArBA,EAAYjB,KACrB,GAAyB,WAArBkB,EAAYlB,KAAmB,CACjC,MAAMuB,EAAQpB,KAAKM,UAAUQ,GAC7BE,EAAaI,GACbT,EAAUQ,KAAKC,EAChB,MAAMJ,EAAahB,KAAKD,aAAae,SACjC,GAAyB,kBAArBA,EAAYjB,KAA0B,CAC/C,MAAMuB,EAAQpB,KAAKC,YAAYa,GAC/BE,EAAaI,GACbT,EAAUQ,KAAKC,EAChB,MAAM,GAAyB,gBAArBN,EAAYjB,KAAwB,CAC7C,MAAMuB,EAAQpB,KAAKG,aAAaW,GAChCE,EAAaI,GACbT,EAAUQ,KAAKC,EAChB,MAAM,GAAyB,gBAArBN,EAAYjB,KAAwB,CAC7C,GAC6B,UAA3Be,eAAAA,EAAkBf,OACS,WAA3Be,aAAgB,EAAhBA,EAAkBf,MAElB,MAAM,IAAIqB,YAAYlB,KAAKjB,gBAAgB6B,IAE7C,GAAyB,UAArBG,EAAYlB,KACd,MAAM,IAAIqB,YAAYlB,KAAKjB,gBAAgB+B,IAE7CH,EAAUU,KACX,MAAM,GAAyB,cAArBP,EAAYjB,KAAsB,CAC3C,GAC6B,UAA3Be,eAAAA,EAAkBf,OACS,WAA3Be,aAAgB,EAAhBA,EAAkBf,MAElB,MAAM,IAAIqB,YAAYlB,KAAKjB,gBAAgB6B,IAI7C,GAFyB,eAArBG,EAAYlB,MAAuBc,EAAUU,MAEJ,WAAzCV,EAAUA,EAAUnB,OAAS,GAAGK,KAClC,MAAM,IAAIqB,YAAYlB,KAAKjB,gBAAgB+B,IAE7CH,EAAUU,KACX,MAAM,GAAyB,SAArBP,EAAYjB,KAAiB,CACtC,GAC6B,UAA3Be,eAAAA,EAAkBf,OACS,WAA3Be,aAAgB,EAAhBA,EAAkBf,MAElB,MAAM,IAAIqB,YAAYlB,KAAKjB,gBAAgB+B,IAE7C,GAAyB,eAArBC,EAAYlB,MAA8C,UAArBkB,EAAYlB,KACnD,MAAM,IAAIqB,YAAYlB,KAAKjB,gBAAgB+B,IAE7C,GACuB,eAArBC,EAAYlB,MACmB,OAA9BkB,EAAoB9B,MAErB,MAAM,IAAIiC,YAAYlB,KAAKjB,gBAAgB+B,IAEpB,eAArBC,EAAYlB,MAAuBc,EAAUU,KAClD,MAAM,GAAyB,UAArBP,EAAYjB,OAEQ,YAA3Be,eAAAA,EAAkBf,OACG,eAArBkB,EAAYlB,MACmB,OAA9BkB,EAAoB9B,OAErB,MAAM,IAAIiC,YAAYlB,KAAKjB,gBAAgB+B,IAGtB,gBAArBA,EAAYjB,OAAwBe,EAAmBE,EAC5D,CAGD,GAAyB,IAArBH,EAAUnB,OACZ,MAAM,IAAI0B,YAAYlB,KAAKjB,gBAAgB6B,IAE7C,OAAOF,CACR,ECpLH,MAAMY,EAAiB,CACrBC,YAAa,UACbC,mBAAmB,GAarB,MAAMC,EAsBJC,YAAYC,GACV,IAAKA,IAAaA,EAASlB,OACzB,MAAM,IAAImB,MAAM,0CAClB5B,KAAK6B,QAAUC,OAAOC,OAAO,CAAA,EAAIT,EAAgBK,EAClD,CAMDK,iBACE,OAAOhC,KAAK6B,QAAQN,WACrB,CAMDU,YACE,OAAOjC,KAAK6B,QAAQpB,MACrB,CAMDyB,gBACE,MAAO,IAAIJ,OAAOK,KAAKnC,KAAK6B,QAAQpB,QAAST,KAAKgC,iBACnD,CASOI,QACN/C,EACAQ,EACAwC,GAEAA,EAAIC,UAAY,EAChB,MAAMC,EAAQF,EAAIG,KAAKnD,GAEvB,OAAKkD,EAEE,CACL1C,OACAZ,MAAOsD,EAAM,GACbE,OAAQF,EAAME,OACdC,MAAOH,EAAMG,OANI,IAQpB,CAODC,SAAStD,iBACP,GAAmB,iBAARA,EAAkB,MAAO,GAEpC,MAAMoB,EAA2B,GAE3Bc,EAAcvB,KAAKgC,iBACnBR,EAAoBxB,KAAK6B,QAAQL,kBACjCoB,EAAa5C,KAAK6B,QAAQpB,OAEhC,IAAK,IAAIoC,EAAY,EAAGA,EAAYxD,EAAIG,SAAUqD,EAAW,CAC3D,MAAMC,EAAUzD,EAAIE,UAAUsD,EAAWxD,EAAIG,QACvCuD,EAAU1D,EAAIE,UAAU,EAAGsD,GAE3BG,EAAwC,CAC5CnD,KAAM0B,EACNtC,MAAO6D,EAAQG,OAAO,GACtBP,MAAO,GAET,IAAIQ,EAASF,EAGb,MAAMG,EAAiBrB,OAAOsB,QAAQR,GAAYS,UAClD,IAAK,MAAOxD,EAAMwC,KAAQc,EAAgB,CACxC,MAAMZ,EAAQvC,KAAKoC,QAAQU,EAASjD,EAAMwC,GAC5B,OAAVE,IACkB,IAAhBA,EAAMG,MACRQ,EAASX,EAETvC,KAAK6B,QAAQyB,YACbJ,IAAWF,GACXE,EAAOjE,MAAMO,OAAS+C,EAAMG,QAE5BQ,EAASF,GAGd,CAED,MAAMO,EAAuBL,EAAOjE,MAAMuE,MAAM,OAE1CtE,EAAwC,QAA5BuE,EAAoB,QAApBC,EAAAX,EAAQR,MAAM,cAAM,IAAAmB,OAAA,EAAAA,EAAElE,cAAM,IAAAiE,EAAAA,EAAI,EAC5CE,EAAUzE,EAAY0E,KAAKC,IAAIN,EAAqB/D,OAAS,EAAG,GAChEL,EAAuD,QAAzC2E,oBAAAC,EAAAhB,EAAQS,MAAM,6BAAStE,yBAAYM,cAAM,IAAAsE,EAAAA,EAAI,EAC3DE,EACJT,EAAqBA,EAAqB/D,OAAS,GAAGA,QACrDN,IAAcyE,EAAUxE,EAAc,GAEzC,IAAIH,EAA+B,CACjCa,KAAMqD,EAAOrD,KACbZ,MAAOiE,EAAOjE,SACViE,EAAOT,OAAS,CAAEA,OAAQS,EAAOT,QAAW,CAAE,EAClDvD,YACAC,cACAwE,UACAK,aAWF,GARAhF,EAAQgB,KAAK6B,QAAQoC,SACjBjE,KAAK6B,QAAQoC,SAASjF,EAAOyB,GAC7BzB,EAGJ6D,GAAaK,EAAOjE,MAAMO,OAAS,EAGrB,OAAVR,EAAgB,SACpB,IACGgB,KAAK6B,QAAQqC,4BACblE,KAAKkC,gBAAgBiC,SAASnF,EAAMa,MAErC,MAAM,IAAI+B,MACR,iDACE5C,EAAMa,yFAKZ,MAAMuE,EAAqBpF,EAAMa,OAAS0B,EAM1C,GAJEC,GACA4C,GACkB,IAAlB3D,EAAOjB,QACPiB,EAAOA,EAAOjB,OAAS,GAAGK,OAAS0B,EACd,CAErB,MAAM8C,EAAY5D,EAAOA,EAAOjB,OAAS,GACzC6E,EAAUpF,OAASD,EAAMC,MACzBoF,EAAUL,UAAYhF,EAAMgF,UAC5BK,EAAUV,QAAU3E,EAAM2E,OAC3B,MACClD,EAAOU,KAAKnC,EAEf,CAED,OAAOyB,CACR,EA3KagB,EAAA6C,eAAiB,CAC7BC,KAAM,MACNC,OAAQ,gBAERC,iBAAkB,SAClBC,sBAAuB,mBAEvBC,OAAQ,oCACRC,oBAAqB,gCACrBC,oBAAqB,gCACrBC,oBAAqB,gCAErBC,aAAc,MACdC,UAAW,OC5Df,MAAMC,EAAS,CACbN,OAAQ,oBACRH,OAAQ,gBACRU,YAAa,MACbC,KAAM,IACNC,MAAO,IACPC,aAAc,OACdC,cAAe,QACfC,KAAM,OACNC,cAAe,KACfC,YAAa,KACbC,YAAa,KACbC,UAAW,MCpBb,MAAMC,EAAS,ID0Bf,MAAAlE,cACU1B,KAAA6F,WAAa,IAAI/G,EACjBkB,KAAS8F,UAAG,IAAIrE,EAAU,CAChChB,OAAQwE,EACRhB,SAAWjF,IACT,GAAmB,YAAfA,EAAMa,KACR,MAAM,IAAIqB,YAAYlB,KAAK6F,WAAW9G,gBAAgBC,IACxD,OAAOA,CAAK,GA+CjB,CAtCC+G,MAAM1G,GACJA,EAAM2G,OAAO3G,GACb,MAAMoB,EAAST,KAAK8F,UAAUnD,SAAStD,GACjC4G,EAAMjG,KAAK6F,WAAWrF,SAASC,GACrC,OAAOT,KAAKkG,eAAeD,EAAIhH,MAChC,CAEOiH,eAAeC,GACrB,MAAuB,WAAnBA,EAAUtG,KACLG,KAAKoG,YAAYD,GAGH,UAAnBA,EAAUtG,KACLG,KAAKqG,WAAWF,GAGlBnG,KAAKsG,cAAcH,EAC3B,CAEOE,WAAWF,GACjB,MAAMI,EAAkB,GACxB,IAAK,MAAMC,KAAYL,EAAUjG,WAC/BqG,EAAKpF,KAAKnB,KAAKkG,eAAeM,IAEhC,OAAOD,CACR,CAEOH,YAAYD,GAClB,MAAMI,EAAmB,CAAA,EACzB,IAAK,MAAMC,KAAYL,EAAUjG,WAC/BqG,EAAKC,EAASjG,MAAQP,KAAKkG,eAAeM,EAASvH,OAErD,OAAOsH,CACR,CAEOD,cAAcH,GACpB,OAAOA,EAAUlH,KAClB,UC9EgB2G,EAAOG,MAAMU,KAAKb"}